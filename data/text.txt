Виды первичных ключей((|))1) Натуральный ключ — это значение, которое уже существует в данных и используется как уникальный идентификатор.
Преимущества натурального ключа
- Нет необходимости создавать дополнительное поле, так как ключ уже содержится в данных
- Может быть понятен и полезен пользователям, так как связан с реальными характеристиками объектов
Недостатки натурального ключа
- Может изменяться, что потребует дополнительных изменений в базе данных
- Может содержать персональные данные
- Может быть слишком сложным или длинным для индексации, снижая скорость работы
2) Auto increment key — это автоматически генерируемое числовое значение, которое увеличивается с каждой новой записью в таблице.
Преимущества auto increment key
- Легко генерируется базой данных, не требует указания значений при добавлении записей, что исключает ошибки при ручном вводе
- Не зависит от содержимого других полей и всегда будет уникальным
Недостатки auto increment key
- Не может быть использован вне системы для идентификации записи
- Подходит только для локальных, а не для распределённых баз данных. В распределённых системах возможны конфликты при
одновременном добавлении записей на разных серверах
3) UUID — это идентификатор, который генерируется случайным образом и гарантирует уникальность не только в пределах одной таблицы,
но и между разными системами и базами данных.
Преимущества UUID
- Гарантирует уникальность не только в одной таблице, но и между разными системами
- Безопасный, так как UUID труднее предсказать, чем простые числовые идентификаторы
- Хорошо подходит для сложных распределённых систем, где данные могут обновляться на разных узлах
Недостатки UUID
- Занимает больше места в памяти, что может замедлить индексирование
- Пользователям сложнее работать с длинными и случайными идентификаторами((|||))Виды JOIN((|))Виды JOIN
1. INNER JOIN объединяет строки из обеих таблиц, где условие соединения выполняется. Если соответствующей строки нет в одной из таблиц, такая строка не попадёт в результат.
2. LEFT JOIN (или LEFT OUTER JOIN) возвращает все строки из левой таблицы и те строки из правой таблицы, которые соответствуют условию соединения. Если соответствующей строки нет в правой таблице, будут возвращены NULL-значения.
3. RIGHT JOIN (или RIGHT OUTER JOIN) аналогичен LEFT JOIN, но возвращает все строки из правой таблицы и только те строки из левой, которые соответствуют условию.
4. FULL JOIN (или FULL OUTER JOIN) объединяет все строки из обеих таблиц независимо от того, существует ли соответствие по условию. Если для строки нет соответствия, в результатах будет стоять NULL.
SELECT table1.column1, table2.column2
FROM table1 JOIN table2 
ON table1.common_column = table2.common_column 
WHERE condition;((|||))Внешний ключ (Foreign key, FK). Гарантии внешних ключей. Каскадные действия. Виды отношений((|))Внешний ключ (Foreign key, FK) — это столбец или комбинация столбцов в одной таблице, которые указывают на первичный ключ
(Primary key) в другой таблице.
Гарантии внешних ключей
- Ссылочная целостность: каждый внешний ключ в одной таблице обязательно указывает на существующую запись в другой таблице
- Запрет нарушения связей: мы не можем удалить запись в таблице «Режиссёров», если она ссылается на существующие записи
в таблице «Фильмов»
Каскадные действия — это специальные настройки, которые определяют, как база данных должна вести себя
при изменении или удалении записей в таблице, от которой зависят другие таблицы.
Виды:
1) CASCADE (каскадное удаление/обновление)
2) SET NULL (установить NULL)
3) NO ACTION (без действия. Нельзя удалить, если есть ссылающиеся записи)
Виды отношений:
1) Отношение один к одному
2) Отношение один ко многим
3) Отношение многие ко многим((|||))Выбор первичного ключа((|))Выбор первичного ключа
- Натуральные ключи используются, когда у вас уже есть уникальное значение, которое может выполнять роль идентификатора
- Auto increment key удобны для большинства простых случаев, когда нужен числовой ключ, не связанный с реальными данными
- UUID стоит применять в распределённых системах или когда нужно обеспечить уникальность ключей в глобальном масштабе((|||))Добавление нового столбца, изменение столбца, удаление столбца sql((|))Добавление нового столбца
ALTER TABLE table_name
ADD column_name datatype constraint;

Изменение типа данных столбца
ALTER TABLE table_name
ALTER COLUMN column_name new_datatype;

Удаление столбца
ALTER TABLE table_name
DROP COLUMN column_name;((|||))Зачем нужна нормализация данных((|))Зачем нужна нормализация данных
- Устранить избыточность — исключить дублирование данных в таблицах
- Повысить целостность данных — если информация меняется в одном месте, она автоматически обновляется везде, где
используется
- Избежать аномалий — предотвращает логические ошибки, которые могут возникнуть при вставке, обновлении или удалении данных
Когда применять денормализацию
- Когда часто выполняются сложные запросы, требующие данных из нескольких таблиц
- Когда нужно повысить скорость чтения данных
Применение нормализации и денормализации
- Нормализация лучше подходит для систем, где важно поддерживать целостность и избежать дублирования 
данных (системы с большим количеством операций обновления и изменения данных).
- Денормализация актуальна для систем, ориентированных на быструю обработку запросов, как 
в аналитических базах данных, где чаще требуется доступ к данным, чем их изменение((|||))Индексы в базе данных. Недостатки индексов((|))Индексы — это специальные структуры данных, которые СУБД создаёт для ускорения операций поиска.
Недостатки индексов
Индексы могут замедлять операции вставки, обновления или удаления данных, так как при этих операциях индекс должен обновляться.((|||))Индексы. Синтаксис создания и удаления индекса. Виды индексов((|))Индексы — это специальные структуры данных, которые используются для ускорения поиска и выборки данных из таблиц.
Синтаксис создания и удаления индекса
CREATE INDEX idx_movies_title ON Movies(title);
DROP INDEX idx_movies_title;
Виды индексов
1) B-Tree-индексы являются стандартным типом индексов в большинстве СУБД. Подходят для запросов с:
• фильтрацией (WHERE) 
• сортировкой (ORDER BY) 
• агрегацией (GROUP BY) 
• диапазонными условиями (BETWEEN, <, >)
2) Hash-индексы работают на основе хеш-функции, которая преобразует ключевое значение в хеш. Это позволяет выполнять быстрый поиск для равенства (=), но делает невозможным выполнение запросов с диапазонами. Подходят для запросов с точным соответствием (WHERE column = value).
3) GiST-индексы — это обобщённые индексы поиска, которые поддерживают работу с более сложными структурами данных. Подходят для работы с геометрическими данными (например, точки, линии, полигоны), JSONB, массивами или другими типами данных с нестандартным сравнением.
4) Full-Text-индексы предназначены для работы с текстовыми данными и позволяют выполнять эффективный поиск слов или фраз в больших текстовых полях. Используется для поиска текстовой информации с учётом морфологии, синонимов и релевантности.
5) Bitmap-индексы используются для столбцов с небольшим количеством уникальных значений. Они работают за счёт представления данных в виде битовых последовательностей.
Рекомендации по выбору индекса
• Используйте B-Tree-индексы по умолчанию для большинства задач • Применяйте Hash-индексы, если нужен исключительно точный поиск 
• Выбирайте GiST-для работы с географическими объектами или массивами 
• Используйте Full-Text для поиска по тексту 
• Применяйте Bitmap, если работаете с аналитическими базами и низкой уникальностью данных((|||))Неявное и явное приведение типов в базе данных((|))Неявное приведение типов
Реляционная СУБД преобразует один тип данных в другой, если это необходимо для выполнения операции.
Явное приведение типов
В некоторых случаях разработчики базы данных явно указывают, что один тип данных должен быть преобразован в другой.
Это может быть сделано с помощью функции преобразования: CAST или CONVERT.((|||))Нормальные формы((|))Нормальные формы — это набор правил, которые помогают упорядочить и оптимизировать структуру таблиц в базе данных.
Основная цель нормализации — устранить дублирование данных, минимизировать избыточность и обеспечить целостность информации
1NF — Первая нормальная форма
Требование:
Все значения в таблице должны быть атомарными (неделимыми), то есть в каждой ячейке должно быть только одно значение.
2NF — Вторая нормальная форма
Требование:
Должна удовлетворять 1NF, и все неключевые атрибуты должны зависеть от всего первичного ключа, 
а не от его части (актуально для составных ключей).
3NF — Третья нормальная форма
Требование:
Должна удовлетворять 2NF, и все неключевые атрибуты должны зависеть только от первичного ключа, 
а не друг от друга (отсутствие транзитивной зависимости).
4NF — Четвёртая нормальная форма
Требование:
Должна удовлетворять 3NF, и не должно быть многозначных зависимостей — когда один атрибут зависит от другого, 
независимо от других атрибутов.((|||))Обновление записей sql. Рекомендации использования UPDATE((|))UPDATE table_name
SET column_name1 = value1, column_name2 = value2, ...
WHERE condition;
Рекомендации использования UPDATE
● Добавляйте условия WHERE всегда, когда это возможно
● Используйте транзакции при массовых обновлениях
● Проверяйте запросы с помощью SELECT
● Создавайте резервные копии данных перед крупными изменениями((|||))Оператор AND, OR, NOT, IN, BETWEEN, LIKE((|))Оператор AND, OR, NOT, IN, BETWEEN, LIKE
SELECT column1, column2, ... 
FROM table_name 
WHERE condition1 AND condition2 AND ...;
SELECT column1, column2, ... 
FROM table_name 
WHERE condition1 OR condition2 OR ...;
SELECT column1, column2, ... 
FROM table_name 
WHERE NOT condition;
SELECT column1, column2, ... 
FROM table_name 
WHERE column_name IN (value1, value2, ...);
SELECT column1, column2, ...
FROM table_name 
WHERE column_name BETWEEN value1 AND value2;
SELECT column1, column2, ... 
FROM table_name 
WHERE column_name LIKE pattern;((|||))Оператор AS sql((|))Оператор AS
SELECT column_name AS alias_name 
FROM table_name;((|||))Операторы UNION, UNION ALL, INTERSECT((|))Операторы UNION, UNION ALL, INTERSECT
UNION — оператор, который объединяет результаты первого и второго запроса, исключая дубликаты
UNION ALL — оператор, который объединяет все результаты без удаления дубликатов. Если строка встречается в обоих запросах, она будет выведена несколько раз
INTERSECT — оператор, который возвращает только те строки, которые присутствуют в обеих выборках (то есть пересечение данных)
EXCEPT — исключает из первой выборки те строки, которые присутствуют во второй выборке
SELECT column1, column2, ... 
FROM table_1 
EXCEPT 
SELECT column1, column2, ... 
FROM table_2;((|||))Основные виды агрегирующих функций sql((|))SUM() - Вычисляет сумму значений в указанном столбце. Работает только с числовыми данными
AVG() - Вычисляет среднее арифметическое значение для столбца. Работает только с числовыми данными
COUNT() - Подсчитывает количество строк в столбце или общее количество записей, если используется COUNT(*)
MAX() - Возвращает максимальное значение в указанном столбце. Подходит для числовых, строковых и дат
MIN() - Возвращает минимальное значение в указанном столбце. Подходит для числовых, строковых и дат((|||))Первичный ключ (Primary key)((|))Первичный ключ (Primary key) — это уникальный идентификатор каждой строки в таблице.
Основные ограничения первичного ключа
- Должен быть уникальным
- Обязательно должен быть заполнен
- Должен быть один на таблицу, который отвечает за идентификацию строк
Важные роли первичного ключа
Идентификация записей
Связи между таблицами((|||))План исполнения запроса EXPLAIN sql((|))План исполнения запроса — это способ, с помощью которого база данных определяет оптимальную стратегию для выполнения SQLзапроса. EXPLAIN — это инструмент, который показывает, как база данных будет исполнять запрос.
Синтаксис EXPLAIN
EXPLAIN SELECT column1, column2, ... 
FROM table_name 
WHERE condition;((|||))Разница между WHERE и HAVING((|))WHERE - Фильтрует строки до группировки 
HAVING - Фильтрует данные после группировки((|||))Синтаксис группировки и агрегирующих функций sql((|))Синтаксис группировки и агрегирующих функций
SELECT column1, column2, ..., aggregate_function(column3) 
FROM table_name 
WHERE condition 
GROUP BY column1, column2, ... 
HAVING condition;((|||))Синтаксис подзапросов. Виды подзапросов((|))Синтаксис подзапросов
SELECT column1, column2 
FROM table_name 
WHERE column3 = ( 
 SELECT column3
 FROM another_table 
 WHERE condition );
● Подзапросы в секции WHERE служат для фильтрации данных. Они выполняются первыми, а их результат используется для ограничения набора данных основного запроса 
● Подзапросы в секции SELECT используются для вычисления дополнительных значений для каждой строки основного запроса 
● Подзапросы в секции FROM формируют временную таблицу, которая становится источником данных для основного запроса
Виды подзапросов
● Скалярный подзапрос возвращает одно значение, которое используется как часть выражения 
SELECT name, (
 SELECT MAX(age) 
 FROM users) AS max_age 
FROM employees;
● Множественный подзапрос возвращает несколько строк или значений, используемых в основных конструкциях, например, IN, ANY, ALL 
SELECT name 
FROM employees 
WHERE department_id IN (
 SELECT id 
 FROM departments 
 WHERE location = 'NY');
● Табличный подзапрос возвращает результат в виде временной таблицы, которая становится источником данных для основного запроса
SELECT sub.name, sub.salary
FROM (
 SELECT name, salary FROM employees WHERE salary > 5000
) AS sub;((|||))Синтаксис транзакций. Уровни изоляции транзакций((|))Синтаксис транзакций
BEGIN; 
-- SQL-операции:
INSERT, UPDATE, DELETE COMMIT; 
-- или 
ROLLBACK;
Частые причины ошибок при выполнении транзакций
1. Ошибки синтаксиса 
2. Нарушение ограничений базы данных (например, уникальности или ссылочной целостности) 
3. Блокировки ресурсов (deadlock)
Уровни изоляции транзакций 
- Read Uncommitted (чтение незафиксированных данных) 
- Read Committed (чтение зафиксированных данных) 
- Repeatable Read (повторяемое чтение) 
- Serializable (сериализуемость)((|||))Создание БД sql((|))Создание БД
CREATE DATABASE name [OPTIONS]
[OPTIONS] — дополнительные параметры
для настройки базы данных (необязательное):
например, CHARACTER SET для указания набора
символов, COLLATE для задания правила сравнения строк((|||))Создание записей sql((|))INSERT INTO table_name (column1, column2, ...)
VALUES (value1,value2 ...); 
ON CONFLICT (column1)
DO UPDATE SET showtime = '2023-11-15 19:30:00';((|||))Создание таблицы sql((|))Создание таблицы
CREATE TABLE table_name (
column1 datatype constraint ,
column2 datatype constraint ,
...
);((|||))Типизация данных. Основные типы базы данных.((|))Типизация данных
Типизация данных помогает БД понимать, какие операции можно выполнить с конкретными данными. У каждого столбца
в таблице есть свой тип данных, который позволяет системе корректно хранить, обрабатывать и проверять данные.
Основные типы
Тип данных | Описание | Пример использования
INTEGER | Целые числа без дробной части | Хранение количества товаров на складе
FLOAT / DOUBLE | Числа с плавающей точкой, допускающие дробную часть | Хранение цены товаров
DECIMAL | Точные дробные числа, особенно для финансовых данных | Хранение денежных значений, таких как баланс счёта
VARCHAR | Текстовые строки с длиной | Хранение имён пользователей, адресов электронной почты
TEXT | Длинные текстовые данные | Хранение описаний товаров, комментариев
DATE | Дата без времени | Хранение даты рождения
TIMESTAMP | Дата и время | Хранение времени создания или изменения записи
BOOLEAN | Логические значения (TRUE / FALSE) | Хранение состояния активности (например, «Активен» или «Неактивен»)
BLOB | Двоичные данные, такие как изображения или файлы | Хранение фотографий профиля или документов((|||))Удаление записей sql. Разница DELETE и DROP((|))DELETE FROM table_name
WHERE condition
DROP DATABASE (TABLE) db_name
Как защитить данные от случайного удаления
● Создавайте резервные копии
● Используйте транзакции
● Используйте SELECT, чтобы проверить, какие данные попадут под удаление
Отличия команд DELETE и DROP
DELETE - Удаляет отдельные записи из таблицы
DROP - Полностью удаляет таблицу или базу данных((|||))cast sql((|))Преобразование данных
cast(columns_number as text) == '2000'
columns_number::text = '2000'((|||))IN, ANY, ALL sql((|))IN, ANY, ALL
IN — проверяет, входит ли значение в список значений.
SELECT * FROM users WHERE country IN ('USA', 'Canada', 'Mexico');
(Выберет пользователей, у которых страна — одна из этих трёх.)
ANY — сравнивает значение с любым из результатов подзапроса (или списка).
SELECT * FROM products WHERE price > ANY (SELECT price FROM products WHERE category = 'Books');
(Выберет товары, цена которых больше хотя бы одной цены книги.)
ANY — сравнивает значение с любым из результатов подзапроса (или списка).
SELECT * FROM products WHERE price > ALL (SELECT price FROM products WHERE category = 'Books');
(Выберет товары, цена которых больше всех цен книг.)((|||))SELECT с LIMIT и OFFSET((|))SELECT с LIMIT и OFFSET
SELECT column1, column2, ... 
FROM table_name 
LIMIT number OFFSET number ;((|||))SELECT с ORDER BY((|))SELECT с ORDER BY
SELECT column1, column2, ... 
FROM table_name 
ORDER BY column1 [ASC|DESC], column2 [ASC|DESC];((|||))
